nav.js
    {
      text: "pureAdmin",
      link: "/pureAdmin/pureAdmin",
    },

    {
      text: "electron",
      link: "/electron/electron"
    },

    {
      text: "js书籍",
      link: "/book/book",
    },

book.md
---
outline: deep
---
### 你不知道的JavaScript
#### 函数声明和函数表达式
```js
如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。

函数声明:
function foo() {
   var a = 3;
   console.log( a ); 
} 
函数表达式:
(function foo(){ 
   var a = 3;
   console.log( a ); 
})(); 
函数表达式分类
一. 匿名函数表达式(回调参数函数)
   setTimeout( function() {
      console.log("I waited 1 second!");
   }, 1000 );
   缺点：
   1. 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。
   2. 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，
   比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑
   自身。
   3. 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让
   代码不言自明。
   解决方案：加上名字即可(行内函数表达式)
   setTimeout( function timeoutHandler() { // <-- 快看，我有名字了！
      console.log( "I waited 1 second!" );
   }, 1000 );
二. 立即执行函数表达式
   1. (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。
   2. 倒置代码的运行顺序，将需要运行的函数放在第二位，在立即执行函数执行之后当作参数传递进去。
   var a = 2;
   (function IIFE( def ) {
      def( window );
   })(function def( global ) {
      var a = 3;
      console.log( a ); // 3
      console.log( global.a ); // 2
   });
   函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中
```
#### 块级作用域
```js
1. with
2. try/catch, try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效
   try {
      undefined(); // 执行一个非法操作来强制制造一个异常
   }
   catch (err) {
      console.log( err ); // 能够正常执行！
   }
   console.log( err ); // ReferenceError: err not found
3. let ,let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）
   var foo = true;
   if (foo) {
      let bar = foo * 2;
      bar = something( bar );
      console.log( bar );
   }
   console.log( bar ); // ReferenceError
   隐式的创建块

   var foo = true;
   函数作用域和块作用域 ｜ 33
   if (foo) {
      { // <-- 显式的快
         let bar = foo * 2;
         bar = something( bar );
         console.log( bar );
      }
   }
   console.log( bar ); // ReferenceError
   显式的创建块
4. let循环
   for (let i=0; i<10; i++) {
      console.log( i );
   }
   console.log( i ); // ReferenceError
   for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其 (重新绑定) 到了循环的每一个迭代中，
   另一种理解，重新绑定
   {
      let j;
      for (j=0; j<10; j++) {
      let i = j; // 每个迭代重新绑定！
      console.log( i );
      }
   }
5. const
6. IIFE 会通过声明并立即执行一个函数来创建作用域
   (function foo(){ .. })()
```
#### var的变量提升
```js
1. 造成原因：
   var a = 2; 拆分为
   var a;   第一个定义声明是在编译阶段进行的
   a = 2;   第二个赋值声明会被留在原地等待执行阶段
   a = 2;

   下述代码：
      a = 2;
      var a;
      console.log( a );
      实际执行
      var a;
      a = 2;
      console.log( a );
      存在变量提升
```
####  函数提升优先于变量提升0
#### 闭包
```js
1. 闭包定义：
   闭包使得函数可以继续访问定义时的词法作用域

   在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。 发现还在引用所以产生了闭包

   这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域
   

   将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包！！！
   var fn;
   function foo() {
      var a = 2;
      function baz() {
         console.log( a );
      }
      fn = baz; // 将 baz 分配给全局变量
   }
   function bar() {
      fn(); // 妈妈快看呀，这就是闭包！   
   }
   foo();
   bar(); // 2

2. 闭包的使用场景
   定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！

   function wait(message) {
      setTimeout( function timer() {
         console.log( message );
      }, 1000 );
   }
   wait( "Hello, closure!" );
将一个内部函数（名为 timer）传递给 setTimeout(..)。timer 具有涵盖 wait(..) 作用域的闭包，因此还保有对变量 message 的引用。
wait(..) 执行 1000 毫秒后，它的内部作用域并不会消失，timer 函数依然保有 wait(..)作用域的闭包。
深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。
引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。
这就是闭包！！！
```
#### 动态作用域和词法作用域

```js
1. 定义： 词法作用域(JavaScript 中的作用域), 
         词法作用域是在写代码或者说定义时确定的(何处声明)
         动态作用域(是JavaScript 另一个重要机制 this 的表亲)
         是在运行时确定的(何处调用)

   function foo() {
     console.log( a ); // 2
   }
   function bar() {
     var a = 3;
     foo();
   }
   var a = 2;
   bar();
```
#### this

```js
1. 定义： 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。   
         this 就是记录的其中一个属性（this 是在运行时进行绑定）
2. 调用栈和调用位置，this注重调用位置
   function baz() {
      // 当前调用栈是：baz
      // 因此，当前调用位置是全局作用域
      console.log( "baz" );
      bar(); // <-- bar 的调用位置
   }
   function bar() {
      // 当前调用栈是 baz -> bar
      // 因此，当前调用位置在 baz 中
      console.log( "bar" );
      foo(); // <-- foo 的调用位置
   }
   function foo() {
      // 当前调用栈是 baz -> bar -> foo
      // 因此，当前调用位置在 bar 中
      console.log( "foo" );
   }
   baz(); // <-- baz 的调用位置

3. this的绑定规则 
   默认绑定(无法应用其他规则时的默认规则)
         function foo() {
            console.log( this.a );
         }
         var a = 2;
         foo(); // 2
         函数调用时应用了 this 的默认绑定，因此 this 指向全局对象
         foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则


   隐式绑定(调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含)
         function foo() {
            console.log( this.a );
         }
         var obj = {
            a: 2,
            foo: foo
         };
         obj.foo(); // 2
         这个函数严格来说都不属于obj 对象。只是引用，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”它。

         对象属性引用链中只有最顶层或者说最后一层会影响调用位置！！！
         function foo() {
            console.log( this.a );
         }
         var obj2 = {
            a: 42,
            foo: foo
         };
         var obj1 = {
            a: 2,
            obj2: obj2
         };
         obj1.obj2.foo(); // 42

         隐式丢失(被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，)
         function foo() {
            console.log( this.a );
         }
         var obj = {
            a: 2,
            foo: foo
         };
         var bar = obj.foo; // 函数别名！
         var a = "oops, global"; // a 是全局对象的属性
         bar(); // "oops, global"
         虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定

         function foo() {
            console.log( this.a );
         }
         function doFoo(fn) {
            // fn 其实引用的是 foo
            fn(); // <-- 调用位置！
         }
         var obj = {
            a: 2,
            foo: foo
         };
         var a = "oops, global"; // a 是全局对象的属性
         doFoo( obj.foo ); // "oops, global"
         参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。

         如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：
         function foo() {
            console.log( this.a );
         }
         var obj = {
            a: 2,
            foo: foo
         };
         var a = "oops, global"; // a 是全局对象的属性
         setTimeout( obj.foo, 100 ); // "oops, global"


         JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：
         function setTimeout(fn,delay) {
            // 等待 delay 毫秒
            fn(); // <-- 调用位置！
         }

         this 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制会影响绑定的调用位置!!!

   显式绑定(强制绑定this)
         API调用的“上下文”
         第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），
         其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。
         举例来说： 
         function foo(el) {
            console.log( el, this.id );
         }
         var obj = {
            id: "awesome"
         };
         // 调用 foo(..) 时把 this 绑定到 obj
         [1, 2, 3].forEach( foo, obj );
         // 1 awesome 2 awesome 3 awesome
   new绑定()
         在传统的面向类的语言中，“构造函数”是类中的一些特殊方法，使用 new 初始化类时会调用类中的构造函数。
         通常的形式是这样的：something = new MyClass(..);

         在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。
         实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已

         使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。
         1. 创建（或者说构造）一个全新的对象。
         2. 这个新对象会被执行 [[ 原型 ]] 连接。
         3. 这个新对象会绑定到函数调用的 this。
         4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。

         function foo(a) {
            this.a = a;
         }
         var bar = new foo(2);
         console.log( bar.a ); // 2
         使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this上。
         new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。

   4中规则的优先级:
         1. 显式绑定优先级更高于隐式绑定
         2. new 绑定比隐式绑定优先级高
            function foo(something) {
               this.a = something;
            }
            var obj1 = {
               foo: foo
            };

            obj1.foo( 2 );
            console.log( obj1.a ); // 2
    
   
            var bar = new obj1.foo( 4 );
            console.log( obj1.a ); // 2
            console.log( bar.a ); // 4
         3. new 绑定和显式绑定  , new 绑定
            function foo(something) {
               this.a = something;
            }
            var obj1 = {};
            var bar = foo.bind( obj1 );
            bar( 2 );
            console.log( obj1.a ); // 2
            var baz = new bar(3);
            console.log( obj1.a ); // 2
            console.log( baz.a ); // 3
            出乎意料！ bar 被硬绑定到 obj1 上，但是 new bar(3) 并没有像我们预计的那样把 obj1.a
            修改为 3。相反，new 修改了硬绑定（到 obj1 的）调用 bar(..) 中的 this。因为使用了
            new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。(判断硬绑定函数是否是被 new 调用，如果是的话就会使用新创建
            的 this 替换硬绑定的 this)
   规则总结:
         1. 函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象。
            var bar = new foo()
         2. 函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是
            指定的对象。
            var bar = foo.call(obj2)
         3. 函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上
            下文对象。
            var bar = obj1.foo()
         4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到
            全局对象。
            var bar = foo()
   参数进行柯里化（预先设置一些参数）方法：
        1. foo.bind( null, 2 )   this强绑定 null 或者 undefined，实际应用的是this的默认绑定规则
           缺点：可能导致修改全局对象
        2. 创建一个空对象，更加安全，不会修改全局对象
            function foo(a,b) {
               console.log( "a:" + a + ", b:" + b );
            }
            // 我们的 DMZ 空对象
            var ø = Object.create( null );
            // 把数组展开成参数
            foo.apply( ø, [2, 3] ); // a:2, b:3
            // 使用 bind(..) 进行柯里化
            var bar = foo.bind( ø, 2 );
            bar( 3 ); // a:2, b:3 
   箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。
            function foo() {
               // 返回一个箭头函数
               return (a) => {
               //this 继承自 foo()
               console.log( this.a );
            };
            }
            var obj1 = {
               a:2
            };
            var obj2 = {
               a:3
            };
            var bar = foo.call( obj1 );
            bar.call( obj2 ); // 2, 不是 3 ！
```
#### 对象
##### 语法
```js
1. 声明（文字）形式
var myObj = {
   key: value
   // ...
};

2. 构造形式
var myObj = new Object();
myObj.key = value;

区别：在文字声明中你可以添加多个键 / 值对，但是在构造形式中你必须逐个添加属性
```
##### 内置对象(对象子类型)

```js
• String
• Number
• Boolean
• Object
• Function
• Array
• Date
• RegExp
• Error
```
##### 属性名访问
```js
.a 语法通常被称为“属性访问”
["a"] 语法通常被称为“键访问”
区别：
. 操作符要求属性名满足标识符的命名规范，
而 [".."] 语法可以接受任意 UTF-8/Unicode 字符串作为属性名

在对象中，属性名永远都是字符串！！！
```
##### 可计算属性名
```js
ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名：
var prefix = "foo";
var myObject = {
[prefix + "bar"]:"hello",
[prefix + "baz"]: "world"
};
myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

##### 深拷贝对象
```js
1. JSON.parse( JSON.stringify( someObj ) );
需要保证可以JOSN序列化，例如：函数、undefined、Symbol或者循环引用
```
##### 属性描述符

electron.md
---
outline: deep
---
#### 主进程和渲染进程通信方式

##### 渲染进程到主进程(单向)
```js
 渲染进程ipcRenderer.send 发送消息，主进程使用 ipcMain.on  接收。
```
##### 渲染进程到主进程(双向)
```js
渲染进程ipcRenderer.invoke , 主进程使用ipcMain.handle 
```
##### 主进程到渲染进程(单向)
```js
主进程win.webContents.send， 渲染进程使用ipcRenderer.on接收消息
```
##### 渲染进程到渲染进程
```js
1. 将主进程作为渲染器之间的消息代理。 这需要将消息从一个渲染器发送到主进程，然后主进程将消息转发到另一个渲染器
2. web技术(localStorage、sessionStorage、indexedDB)
3. 从主进程将一个 MessagePort 传递到两个渲染器。 这将允许在初始设置后渲染器之间直接进行通信
```
#### 无跨域问题
```js
1. 使用node.js发送请求
2. 使用electron net发送请求
```

realProject.md
#### 100ms轮询数据构建趋势图
```js
1. 为了让数组不再增加
采用2的n次方处理，均匀采点
当数组为100的间隔两个取20个点，100到200之前，每隔两个push点进去，
当为200的时候，总数组就有100个点，然后均匀两次，这样得到了每4个间隔的点，总数组还是50个
当200~400之前，每隔4个push进入，当400就有100，然后处理成50
... 一次类推，这样就保持50~100个点之前，可以看到趋势图了
```
